<html>
  <head>
    <title></title>
    <style>
      td{
        text-align: center;
      }
    </style>

    <link href="css/bootstrap.css" rel="stylesheet" media="screen">
  </head>
  <body>
    <!-- A navbar -->
    <div class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="#">CSE 150 D-Separation Graph</a>
        <ul class="nav">
          <li class="active"><a href="#"><i class="icon-home"></i> Home</a></li>
          <li><a href="#"><i class="icon-book"></i> Course Home Page</a></li>
          <li><a href="#"><i class="icon-search"></i> Useful Links</a></li>
        </ul>
      </div>
    </div>


    <canvas id="viewport" width="1000" height="400"></canvas>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
    <script src="js/bootstrap.js"></script>
    
    <script src="lib/arbor.js"></script>
    <script src="_/graphics.js"></script>
   <!-- <script src="main.js"></script>--> 
    <script>

      //Declare all the variables
      var nodeA;
      var nodeB;
      var nodeC;
      var nodeD;
      var nodeE;
      var nodeF;
      var nodeG;
      var nodeH;
      var NodeList = [];
      var ExampleNodeList = [];
      var EdgeList = [];
      var ExampleEdgeList = [];
      var edgeAC; 
      var edgeCF; 
      var edgeBF; 
      var edgeCG; 
      var edgeAD; 
      var edgeDG; 
      var edgeDH;
      var edgeEH;


      /**
       * Class: Node
       **/
      function Node(name, x, y, mass, evidence, target, targetY, visited){
        this.name = name;
        this.x = x;
        this.y = y;
        this.mass = mass;
        //Red for evidence set
        this.evidence = evidence;
        //Blue for x set
        this.target = target;
        //Green for y set
        this.targetY = targetY;
        this.visited = visited;
      }
      /**
       * Class: Edge
       **/
       function Edge(name, from, to, highlighted, rule){
        this.name = name;
        this.from = from;
        this.to = to;
        this.rule = rule;
        this.highlighted = highlighted;
       }

    (function($){

      var Renderer = function(canvas){
      var canvas = $(canvas).get(0)
      var ctx = canvas.getContext("2d");
      var gfx = arbor.Graphics(canvas)
      var particleSystem

      var that = {
      init:function(system){
        //
        // the particle system will call the init function once, right before the
        // first frame is to be drawn. it's a good place to set up the canvas and
        // to pass the canvas size to the particle system
        //
        // save a reference to the particle system for use in the .redraw() loop
        particleSystem = system

        // inform the system of the screen dimensions so it can map coords for us.
        // if the canvas is ever resized, screenSize should be called again with
        // the new dimensions
        particleSystem.screenSize(canvas.width, canvas.height) 
        particleSystem.screenPadding(100) // leave an extra 80px of whitespace per side
        
        // set up some event handlers to allow for node-dragging
        that.initMouseHandling()
      },
      
      redraw:function(){
        // 
        // redraw will be called repeatedly during the run whenever the node positions
        // change. the new positions for the nodes can be accessed by looking at the
        // .p attribute of a given node. however the p.x & p.y values are in the coordinates
        // of the particle system rather than the screen. you can either map them to
        // the screen yourself, or use the convenience iterators .eachNode (and .eachEdge)
        // which allow you to step through the actual node objects but also pass an
        // x,y point in the screen's coordinate system
        // 
        for (var i = 0; i < NodeList.length; i++){
          //alert("e");
          var tmp = NodeList[i];
          particleSystem.addNode(tmp.name, {name: tmp.name, x: tmp.x, y: tmp.y, mass: 2, evidence: tmp.evidence, target: tmp.target, targetY: tmp.targetY});
        }
        for(var i = 0; i < ExampleNodeList.length; i++){
          var tmp = ExampleNodeList[i];
          particleSystem.addNode(tmp.name, {name: tmp.name, x: tmp.x, y: tmp.y, mass: 2, evidence: tmp.evidence, target: tmp.target, targetY: tmp.targetY});
        }
        for (var i = 0; i < EdgeList.length; i++){
          var tmp = EdgeList[i];
          //console.log(tmp.highlighted);
          var from = particleSystem.getNode(tmp.from);
          var to = particleSystem.getNode(tmp.to);
          particleSystem.addEdge(from, to, {weight: 2, name: tmp.name, highlighted: tmp.highlighted, rule: tmp.rule});
        }
        for(var i = 0; i < ExampleEdgeList.length; i++){
          var tmp = ExampleEdgeList[i];
          var from = particleSystem.getNode(tmp.from);
          var to = particleSystem.getNode(tmp.to);
          particleSystem.addEdge(from, to, {weight: 2, name: tmp.name, highlighted: tmp.highlighted, rule: tmp.rule});
        }
    
        ctx.fillStyle = "white"
        ctx.fillRect(0,0, canvas.width, canvas.height)
        
        var nodeBoxes = {}
        particleSystem.eachNode(function(node, pt){
          // node: {mass:#, p:{x,y}, name:"", data:{}}
          // pt:   {x:#, y:#}  node position in screen coords

          // draw a rectangle centered at pt
          var w = 10
          if(node.data.evidence)
            ctx.fillStyle = "red"
          else if(node.data.target)
            ctx.fillStyle = "blue"
          else if(node.data.targetY)
            ctx.fillStyle = "green"
          else
            ctx.fillStyle = "black"
          //ctx.fillStyle = (node.data.evidence) ? "red" : "black"
          //ctx.fillRect(pt.x-w/2, pt.y-w/2, w,w)
          ctx.beginPath()
          ctx.arc(node.p.x, node.p.y, 10, 0, 2*Math.PI);
          ctx.fillText(node.data.name, node.p.x+10, node.p.y-3);
          ctx.fill();
          nodeBoxes[node.name] = [node.p.x, node.p.y, 22, 15]
        })   

        particleSystem.eachEdge(function(edge, pt1, pt2){
          // edge: {source:Node, target:Node, length:#, data:{}}
          // pt1:  {x:#, y:#}  source position in screen coords
          // pt2:  {x:#, y:#}  target position in screen coords

          // draw a line from pt1 to pt2
          var weight = edge.data.weight
          var start = nodeBoxes[edge.data.name.charAt(0)]
          var end = nodeBoxes[edge.data.name.charAt(1)]
          ctx.save() 
          ctx.beginPath()
          ctx.lineWidth = (!isNaN(weight)) ? parseFloat(weight) : 1;
          var currentEdge = findEdgeByName(edge.data.name)
          if(currentEdge != null){
            if(currentEdge.highlighted)
              ctx.strokeStyle = "#99FFFF"
            else
              ctx.strokeStyle = "#cccccc"
          }
          else{
            ctx.strokeStyle = "#cccccc"
          }
          
          ctx.fillStyle = null

          ctx.moveTo(start[0], start[1])//Tail
          var endx = end[0]
          var endy = end[1]
          if(start[0] > end[0] && start[1] == end[1]){
            endx = end[0] + 12;
          }
          else if(start[0] > end[0]){//The node is on the left side
            endx = end[0] + 10;
            endy = end[1] - 10;
          }
          else if(start[1] == end[1] && start[0] < end[0]){
            endx = end[0] - 12;
          }                  
          else{
            endx = end[0] - 10;
            endy = end[1] - 10;
          }

          //ctx.lineTo(end[0]-5, end[1]-5)//Head
          ctx.lineTo(endx, endy)

          ctx.stroke()
          ctx.restore()

          // draw an arrowhead if this is a -> style edge
          
          ctx.save()
          // move to the head position of the edge we just drew
          var wt = !isNaN(weight) ? parseFloat(weight) : 1
          var arrowLength = 12 + wt
          var arrowWidth = 4 + wt
          ctx.fillStyle = "#cccccc"
          ctx.translate(endx, endy);
          ctx.rotate(Math.atan2(endy - start[1], endx - start[0]));

          // delete some of the edge that's already there (so the point isn't hidden)
          ctx.clearRect(-arrowLength/2,-wt/2, arrowLength/2,wt)

          // draw the chevron
          ctx.beginPath();
          ctx.moveTo(-arrowLength, arrowWidth);
          ctx.lineTo(0, 0);
          ctx.lineTo(-arrowLength, -arrowWidth);
          ctx.lineTo(-arrowLength * 0.8, -0);
          ctx.closePath();
          ctx.fill();
          ctx.restore()

        })

      },
      
      initMouseHandling:function(){
        // no-nonsense drag and drop (thanks springy.js)
        var dragged = null;

        // set up a handler object that will initially listen for mousedowns then
        // for moves and mouseups while dragging
        var handler = {
          clicked:function(e){
            var pos = $(canvas).offset();
            _mouseP = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)
            dragged = particleSystem.nearest(_mouseP);

            if (dragged && dragged.node !== null){
              // while we're dragging, don't let physics move the node
              dragged.node.fixed = true
            }

            $(canvas).bind('mousemove', handler.dragged)
            $(window).bind('mouseup', handler.dropped)

            return false
          },
          dragged:function(e){
            var pos = $(canvas).offset();
            var s = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)

            if (dragged && dragged.node !== null){
              var p = particleSystem.fromScreen(s)
              dragged.node.p = p
            }

            return false
          },

          dropped:function(e){
            if (dragged===null || dragged.node===undefined) return
            if (dragged.node !== null) dragged.node.fixed = false
            dragged.node.tempMass = 1000
            dragged = null
            $(canvas).unbind('mousemove', handler.dragged)
            $(window).unbind('mouseup', handler.dropped)
            _mouseP = null
            return false
          }
        }
        
        // start listening
        $(canvas).mousedown(handler.clicked);

      },
      
    }
    return that
  }    

   // helpers for figuring out where to draw arrows (thanks springy.js)
  var intersect_line_line = function(p1, p2, p3, p4)
  {
    var denom = ((p4.y - p3.y)*(p2.x - p1.x) - (p4.x - p3.x)*(p2.y - p1.y));
    if (denom === 0) return false // lines are parallel
    var ua = ((p4.x - p3.x)*(p1.y - p3.y) - (p4.y - p3.y)*(p1.x - p3.x)) / denom;
    var ub = ((p2.x - p1.x)*(p1.y - p3.y) - (p2.y - p1.y)*(p1.x - p3.x)) / denom;

    if (ua < 0 || ua > 1 || ub < 0 || ub > 1)  return false
      return arbor.Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
  }

  var intersect_line_box = function(p1, p2, boxTuple)
  {
    var p3 = {x:boxTuple[0], y:boxTuple[1]},
        w = boxTuple[2],
        h = boxTuple[3]

          var tl = {x: p3.x, y: p3.y};
    var tr = {x: p3.x + w, y: p3.y};
    var bl = {x: p3.x, y: p3.y + h};
    var br = {x: p3.x + w, y: p3.y + h};

    return intersect_line_line(p1, p2, tl, tr) ||
      intersect_line_line(p1, p2, tr, br) ||
      intersect_line_line(p1, p2, br, bl) ||
      intersect_line_line(p1, p2, bl, tl) ||
      false
  }

  $(document).ready(function(){
    var sys = arbor.ParticleSystem(0, 0, 0.5) // create the system with sensible repulsion/stiffness/friction
    sys.parameters({gravity:true}) // use center-gravity to make the graph settle nicely (ymmv)
    sys.renderer = Renderer("#viewport") // our newly created renderer will have its .init() method called shortly by sys...

    


    // add some nodes to the graph and watch it go...
    // or, equivalently:
    //
    // sys.graft({
    //   nodes:{
    //     f:{alone:true, mass:.25}
    //   }, 
    //   edges:{
    //     a:{ b:{},
    //         c:{},
    //         d:{},
    //         e:{}
    //     }
    //   }
    // })
    
  })

})(this.jQuery)

      //Init condition, set up edges and nodes
      function init(){
        //name, x, y, mass, evidence, target, targetY){
        nodeA = new Node("A", 350, 100, 2, false,  false, false, false);
        nodeB = new Node("B", 50,  200,  2, false, false, false, false);
        nodeC = new Node("C", 250, 200, 2, false,  false, false, false);
        nodeD = new Node("D", 450, 200, 2, false, false, false, false);
        nodeE = new Node("E", 650, 200, 2, false, false, false, false);
        nodeF = new Node("F", 150, 300, 2, false, false, false, false);
        nodeG = new Node("G", 350, 300, 2, false,  false, false, false);
        nodeH = new Node("H", 550, 300, 2, false,  false, false, false);

        //Here's for the three possible blocking path

        //Rule #1, intervening cause
        node1 = new Node("1", 720, 50, 2, false, false, false);
        node2 = new Node("2", 795, 50, 2, true, false, false);
        node3 = new Node("3", 870, 50, 2, false, false, false);
        edge12 = new Edge("12", "1", "2", false, true);
        edge23 = new Edge("23", "2", "3", false, true);
        //Rule #2, comman cause
        node4 = new Node("4", 720, 150, 2, false, false, false);
        node5 = new Node("5", 795, 150, 2, true, false, false);
        node6 = new Node("6", 870, 150, 2, false, false, false);

        edge54 = new Edge("54", "5", "4", false, true);
        edge56 = new Edge("56", "5", "6", false, true);
        //Rule #3, no observed common effect
        node7 = new Node("7", 720, 250, 2, false, false, false);
        node8 = new Node("8", 795, 250, 2, false, false, false);
        node9 = new Node("9", 870, 250, 2, false, false, false);
        node10 = new Node("W", 760, 300, 2, false, false, false);
        node11 = new Node("K", 835, 300, 2, false, false, false);
        
        edge78 = new Edge("78", "7", "8", false, true);
        edge98 = new Edge("98", "9", "8", false, true);
        edge8W = new Edge("8W", "8", "W", false, true);
        edge8K = new Edge("8K", "8", "K", false, true);

        NodeList = [nodeA, nodeB, nodeC, nodeD, nodeE, nodeF, nodeG, nodeH] 
        ExampleNodeList = [node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11];


        edgeAC = new Edge("AC", "A", "C", false, false);  
        edgeCF = new Edge("CF", "C", "F", false, false);
        edgeBF = new Edge("BF", "B", "F", false, false);
        edgeCG = new Edge("CG", "C", "G", false, false);
        edgeAD = new Edge("AD", "A", "D", false, false);
        edgeDG = new Edge("DG", "D" ,"G", false, false);
        edgeDH = new Edge("DH", "D", "H", false, false);
        edgeEH = new Edge("EH", "E", "H", false, false);
        EdgeList = [edgeAC, edgeCF, edgeBF, edgeCG, edgeAD, edgeDG, edgeDH,edgeEH];
        ExampleEdgeList = [edge12, edge23, edge54, edge56, edge78, edge98, edge8K, edge8W];

        alert("init");
      }
      //Function update listen to the radio button clicked and update
      //the node as required.
      function update(){
        for(var i = 0; i < EdgeList.length; i++){
          EdgeList[i].highlighted = false;
        }
        //Case for node A
        var radios = document.getElementById('nodeA_X');

        //Node A update
        if(document.getElementById('nodeA_X').checked){
          nodeA = new Node("A", 350, 100, 2, false,  true, false, false);
          NodeList[0] = nodeA;
        }
        else if(document.getElementById('nodeA_Y').checked){
          nodeA = new Node("A", 350, 100, 2, false, false, true, false);
          NodeList[0] = nodeA;
        }
        else if(document.getElementById('nodeA_E').checked){
          nodeA = new Node("A", 350, 100, 2, true, false, false, false);
          NodeList[0] = nodeA;
        }
        else if(document.getElementById('nodeA_C').checked){
          nodeA = new Node("A", 350, 100, 2, false, false, false, false);
          NodeList[0] = nodeA;
        }

        //Node B update
        if(document.getElementById('nodeB_X').checked){
          nodeB = new Node("B", 50, 200, 2, false,  true, false, false);
          NodeList[1] = nodeB;
        }
        else if(document.getElementById('nodeB_Y').checked){
          nodeB = new Node("B", 50, 200, 2, false, false,  true, false);
          NodeList[1] = nodeB;
        }
        else if(document.getElementById('nodeB_E').checked){
          nodeB = new Node("B", 50, 200, 2, true, false,  false, false);
          NodeList[1] = nodeB;
        }
        else if(document.getElementById('nodeB_C').checked){
          nodeB = new Node("B", 50, 200, 2, false, false,  false, false);
          NodeList[1] = nodeB;
        }



        //Node C update
        if(document.getElementById('nodeC_X').checked){
          nodeC = new Node("C", 250, 200, 2, false,  true, false, false);
          NodeList[2] = nodeC;
        }
        else if(document.getElementById('nodeC_Y').checked){
          nodeC = new Node("C", 250, 200, 2, false, false,  true, false);
          NodeList[2] = nodeC;
        }
        else if(document.getElementById('nodeC_E').checked){
          nodeC = new Node("C", 250, 200, 2, true, false,  false, false);
          NodeList[2] = nodeC;
        }
        else if(document.getElementById('nodeC_C').checked){
          nodeC = new Node("C", 250, 200, 2, false, false,  false, false);
          NodeList[2] = nodeC;
        }



        //Node D update
        if(document.getElementById('nodeD_X').checked){
          nodeD = new Node("D", 450, 200, 2, false,  true, false, false);
          NodeList[3] = nodeD;
        }
        else if(document.getElementById('nodeD_Y').checked){
          nodeD = new Node("D", 450, 200, 2, false, false,  true, false);
          NodeList[3] = nodeD;
        }
        else if(document.getElementById('nodeD_E').checked){
          nodeD = new Node("D", 450, 200, 2, true, false,  false, false);
          NodeList[3] = nodeD;
        }
        else if(document.getElementById('nodeD_C').checked){
          nodeD = new Node("D", 450, 200, 2, false, false,  false, false);
          NodeList[3] = nodeD;
        }


        //Node E update
        if(document.getElementById('nodeE_X').checked){
          nodeE = new Node("E", 650, 200, 2, false,  true, false, false);
          NodeList[4] = nodeE;
        }
        else if(document.getElementById('nodeE_Y').checked){
          nodeE = new Node("E", 650, 200, 2, false, false,  true, false);
          NodeList[4] = nodeE;
        }
        else if(document.getElementById('nodeE_E').checked){
          nodeE = new Node("E", 650, 200, 2, true, false,  false, false);
          NodeList[4] = nodeE;
        }
        else if(document.getElementById('nodeE_C').checked){
          nodeE = new Node("E", 650, 200, 2, false, false,  false, false);
          NodeList[4] = nodeE;
        }


        //Node F update
        if(document.getElementById('nodeF_X').checked){
          nodeF = new Node("F", 150, 300, 2, false,  true, false, false);
          NodeList[5] = nodeF;
        }
        else if(document.getElementById('nodeF_Y').checked){
          nodeF = new Node("F", 150, 300, 2, false, false,  true, false);
          NodeList[5] = nodeF;
        }
        else if(document.getElementById('nodeF_E').checked){
          nodeF = new Node("F", 150, 300, 2, true, false,  false, false);
          NodeList[5] = nodeF;
        }
        else if(document.getElementById('nodeF_C').checked){
         nodeF = new Node("F", 150, 300, 2, false, false,  false, false);
          NodeList[5] = nodeF;
        }

        //Node G update
        if(document.getElementById('nodeG_X').checked){
          nodeG = new Node("G", 350, 300, 2, false,  true, false, false);
          NodeList[6] = nodeG;
        }
        else if(document.getElementById('nodeG_Y').checked){
          nodeG = new Node("G", 350, 300, 2, false, false,  true, false);
          NodeList[6] = nodeG;
        }
        else if(document.getElementById('nodeG_E').checked){
          nodeG = new Node("G", 350, 300, 2, true, false,  false, false);
          NodeList[6] = nodeG;
        }
        else if(document.getElementById('nodeG_C').checked){
          nodeG = new Node("G", 350, 300, 2, false, false,  false, false);
          NodeList[6] = nodeG;
        }

        //Node H update
        if(document.getElementById('nodeH_X').checked){
          nodeH = new Node("H", 550, 300, 2, false,  true, false, false);
          NodeList[7] = nodeH;
        }
        else if(document.getElementById('nodeH_Y').checked){
          nodeH = new Node("H", 550, 300, 2, false, false,  true, false);
          NodeList[7] = nodeH;
        }
        else if(document.getElementById('nodeH_E').checked){
          nodeH = new Node("H", 550, 300, 2, true, false,  false, false);
          NodeList[7] = nodeH;
        }
        else if(document.getElementById('nodeH_C').checked){
          nodeH = new Node("H", 550, 300, 2, false, false,  false, false);
          NodeList[7] = nodeH;
        }
        
      }

      function clearNodeVisit(){
        for(var i = 0; i < NodeList.length; i++){
          NodeList[i].visited = false;
        }
      }
      //Check if all the nodes are visited
      function checkIfAllVisited(){
        for(var i = 0; i < NodeList.length; i++){
          if (NodeList[i].visited == false)
            return false;
        }
        console.log("return true from check all visited");
        return true;
      }
      function checkIsEdgeContainVisitedNode(edge){
        for(var i = 0; i < NodeList.length; i++){
          if(NodeList[i].visited == true && 
            edge.name.indexOf(NodeList[i].name) != -1)
            return true;
        }
        return false;
      }

      function FindCurrentNodesEdgeTo(current, to){
        var done = false;
        if(current.visited == true){
          console.log("return here");
          return;
        }
        
        var tmp = [];
        var index = 0;
        for(var i = 0; i < EdgeList.length; i++){
          //Find all edges that contain the name
          if(EdgeList[i].name.indexOf(current.name) != -1){
            if(checkIsEdgeContainVisitedNode(EdgeList[i])){

            }else{
              //The edge contain the node we want to find
              if(EdgeList[i].name.indexOf(to) != -1){
                tmp[index] = EdgeList[i];
                done = true;
                return tmp;
              }else{
                tmp[index] = EdgeList[i];
                index++;
              }
            }
          }
        }
        console.log("node that set to visited is : " + current.name);
        current.visited = true;
        for(var i = 0; i < tmp.length; i++){
          console.log(tmp[i].name);
        }
        var empty = [];
        var result =  empty.concat(tmp);
        console.log("\n\n");
        if(checkIfAllVisited() == false){
          console.log("enter if node is not all visited");
          for(var i = 0; i < tmp.length; i++){
            var returnLst = FindCurrentNodesEdgeTo(findNodeByName(tmp[i].name.replace(current.name, "")), to);
            if(returnLst == null || returnLst.length == 0){
              result = result.concat(returnLst);
            }
            else {
              for(var j = 0; j < returnLst.length; j++){

                if(typeof returnLst[j] == "undefined"){
                  continue;
                }
                else if(returnLst[j].name.indexOf(to) != -1){
                  result = result.concat(returnLst);
                  return result;
                }
              }
              result = result.concat(returnLst);
            }
          }
        }
        return result;
      }

      //Return a list of edge that is adjacent to current node
      //Ex: A will return AC & AD
      function currentNodesEdge(node){
        if(node.visited == true){
          console.log("return here");
          return;
        }
        
        var tmp = [];
        var index = 0;
        for(var i = 0; i < EdgeList.length; i++){
          //Find all edges that contain the name
          if(EdgeList[i].name.indexOf(node.name) != -1){
            if(checkIsEdgeContainVisitedNode(EdgeList[i])){

            }else{
              tmp[index] = EdgeList[i];
              index++;
            }
          }
        }
        console.log("node that set to visited is : " + node.name);
        node.visited = true;
        for(var i = 0; i < tmp.length; i++){
          console.log(tmp[i].name);
        }
        var empty = [];
        var result =  empty.concat(tmp);
        console.log("\n\n");
        if(checkIfAllVisited() == false){
          console.log("enter if");
          for(var i = 0; i < tmp.length; i++){
            result = result.concat(currentNodesEdge(findNodeByName(tmp[i].name.replace(node.name, ""))));
          }
        }
        return result;
      }

      function printAllNotVisited(){
        for(var i = 0; i < NodeList.length; i++){
          if(NodeList[i].visited == false){
            console.log("haven't visited: " + NodeList[i].name);
          }
        }
      }

      function printPathFromTo(from, to){
        console.log("from: " + from + ", to: " + to);
        var current = findNodeByName(from);
        if(current == null){
          return;
        }
        var lst = FindCurrentNodesEdgeTo(current,to);
        console.log(lst);
        if(lst == null){
          return
        }
        for(var i = 0; i < lst.length; i++){
          if(typeof lst[i] == "undefined"){
              console.log("\n");
              lst.splice(i, 1);
          }else{
              console.log("before getting path to : " + lst[i].name);
          }
        }
        var tmp = gettingThePath(lst, from, to);
        for(var i = 0; i < tmp.length; i++){
          console.log("path to take : " + tmp[i].name);
        }

        //This part is for highlighting the edges
        for(var j = 0; j < tmp.length; j++){
          for(var i = 0; i < EdgeList.length; i++){
            if(EdgeList[i].name.indexOf(tmp[j].name) != -1){
              console.log("highlight " + EdgeList[i].name);
              var tmpEdge = EdgeList[i];
              EdgeList[i] = new Edge(tmpEdge.name, tmpEdge.from, tmpEdge.to, true, false);
            }
          }
        }
      }
      
      /*
       * This is the function for getting a path from node A to B by giving all the possible edges and work from bottom up
       */
      function gettingThePath(lst, from, to){
       
        if(lst.length < 2)
          return lst;
        var end = lst[lst.length-1];
        var endStr = end.name;
        console.log("end is " + endStr);
        console.log("to is " + to);   
        endStr = endStr.replace(to, ""); 
        var tmp_to = endStr;
        console.log("now is " + endStr.replace(to, ""));
        var stop = 0;
        for(var j = lst.length -2; j >= 0; j--){
          if(lst[j].name.indexOf(endStr) == -1){
            console.log("here");
            lst.splice(j, 1);
          }else{
            stop = j;
            break;
          }
        }
        console.log(lst);
        var reset = true;
        var tmpList = [];
        if(reset){
          for(var i = 0; i < lst.length; i ++){
            tmpList[i] = lst[i];
          }
          reset = false;
        }
        while(stop > 0){
          
          console.log("\nanother iteration");
          console.log(tmpList);
          for(var i = 0; i < tmpList.length; i++){
            console.log("lst contains: " + tmpList[i].name);
          }
          if(reset){
            console.log("reset");
            for(var i = 0; i < lst.length; i ++){
              tmpList[i] = lst[i];
            }
            reset = false;
          }else{
            if(tmpList[stop].name.indexOf(from) != -1){
              console.log("return since found");
              console.log("current stop is " + stop);
              for(var i = stop-1 ; i >= 0; i--){
                tmpList.splice(i, 1);
              }
              return tmpList;
            }
          }
          console.log("stop is " + stop);
          end = tmpList[stop];
          console.log(end);
          endStr = end.name;
          console.log("end is " + endStr);
          console.log("tmp to is " + tmp_to);
          endStr = endStr.replace(tmp_to, ""); 
          tmp_to = endStr;
          console.log("now is " + endStr);
          for(var j = stop - 1; j >= 0; j--){
            if(lst[j].name.indexOf(endStr) == -1){
              console.log("here");
              console.log("removing" + lst[j].name);
              tmpList.splice(j, 1);
              console.log("current j is " + j);
              console.log(tmpList.length);
              console.log(lst.length);
            }else{
              stop = j;
              break;
            }
          }
          if(j == -1){
            stop = 0;
          }
          if(stop != 0){
            console.log("continue, stop is " + stop);
            continue;
          }
          if(tmpList[0].name.indexOf(from) == -1){
            console.log("wrong path, reset");
            reset = true;
            lst.splice(lst.indexOf(tmpList[0]), 1);
            stop = lst.length-1;
            console.log("reset stop to " + stop);
            tmp_to = to;
          }else{
            console.log("in return, tmp_to is " + tmp_to);
            while(tmpList[0].name.indexOf(tmp_to) == -1){
              tmpList.splice(0, 1);
            }
            stop = 0;
            console.log("2_returning list");
            return tmpList;
          }
        }
        console.log(lst);
        console.log("1_returning list");
        return lst;
      }
      
      function allPath(){
        for(var i = 0; i < NodeList.length; i++){
          var current = NodeList[i];
          printAllNotVisited();
          //NodeList[i].visited = true;
          console.log("Path for " + current.name + " to other nodes");
          var tmp = currentNodesEdge(current);
          for(var j = 0; j < tmp.length; j++){
            if(typeof tmp[j] == "undefined"){
              console.log("\n");
            }else{
              console.log(tmp[j].name);
            }
          }
          console.log("\n\n\n");
          clearNodeVisit();
          console.log("called clear node");
        }
      }
      /*function printPath(){
         for(var j = 0; j < tmp.length; j++){
            console.log(tmp[j].name.replace(current.name, ""));
            var tmp2 = currentNodesEdge(findNodeByName(tmp[j].name.replace(current.name, "")));
            for(var k = 0; k < tmp2.length; k++){
              console.log(tmp2[k].name.replace(current.name, ""));
            }
            console.log("returned from tmp2");
          }
      }*/
      //This function will return the node based on the name provided
      function findNodeByName(str){
        for(var i = 0; i < NodeList.length; i++){
          if(NodeList[i].name == str)
            return NodeList[i];
        }
        return null;
      }
      function findEdgeByName(str){
        for(var i = 0; i < EdgeList.length; i++){
          if(EdgeList[i].name == str){
            return EdgeList[i];
          }
        }
      }

      function getNodeMarkedX(){
        for(var i = 0; i < NodeList.length; i++){
          if(NodeList[i].target == true){
            return NodeList[i].name;
          }
        }
        return null;
      }
       function getNodeMarkedY(){
        for(var i = 0; i < NodeList.length; i++){
          if(NodeList[i].targetY == true){
            return NodeList[i].name;
          }
        }
        return null;
      }

      function D_Separation(){
        //printPathFromTo(getNodeMarkedX(), getNodeMarkedY());
        var visited = [];
        visited[0] = getNodeMarkedX();
        var end = getNodeMarkedY();
        document.getElementById("result").innerHTML = "";
        BreadthFirstSearch(visited, end);
      }
      function adjacentNodes(nodeX){
        var adjacent = [];
        var index = 0;
        for(var i = 0; i < EdgeList.length; i++){
          //Find all edges that contain the name
          if(EdgeList[i].name.indexOf(nodeX) != -1){
            var node = findNodeByName(EdgeList[i].name.replace(nodeX, ""));
            adjacent[index] = node.name;
            index++;
          }
        }
        return adjacent;
      }
      function BreadthFirstSearch(visited, end){
        //Getting the last element
        var last_node = visited[visited.length-1];
        //Getting the adjacent nodes
        var adjacent = adjacentNodes(last_node);
        for(var i =0; i < adjacent.length; i++){
          var node = adjacent[i];
          //Check if visited contains the current node
          if(visited.indexOf(node) != -1){
            continue;
          }
          //If it's found
          if(node == end){
            visited.push(node);
            setTimeout(printPath(visited), 50000);
            //printPath(visited);

            visited.pop();
          }
        }
         for(var i =0; i < adjacent.length; i++){
            var node = adjacent[i];
           if(visited.indexOf(node) != -1 || node == end){
            continue;
           }
           visited.push(node);
           BreadthFirstSearch(visited, end);
           visited.pop();
         }
      }
      function printPath(visited){       
        var str = ""
        for(var i = 0; i < visited.length; i++){
          str += visited[i];
        }
        var isDependent = checkRules(visited);
        var printOut = "";
        if(isDependent == "Dependent"){
          printOut = " <b class=\"text-warning\">Dependent</b>";
        }else{
          printOut = " <b class=\"text-success\">Independent</b>";
        }
        var result = document.getElementById("result").innerHTML += "<button class=\"btn\" onClick=\"highlightPath('"+str+"')\">Path : " + str + printOut + "</button><br/><br/>";
      }
      function checkRules(visited){
        if(visited.length <= 2){
          return "Dependent";
        }
        else{
          //Check #1 
          var EdgeTmp = []
          for(var j = 0; j < visited.length; j++){
            for(var i = 0; i < EdgeList.length; i++){
              if(j+1 < visited.length && EdgeList[i].name.indexOf(visited[j]) != -1 && EdgeList[i].name.indexOf(visited[j+1]) != -1){
                var tmpEdge = EdgeList[i];
                EdgeTmp.push(tmpEdge);
              }
            }
          }
          console.log(EdgeTmp);
          var index = 0;
          for(var i = 0; i < EdgeTmp.length; i++){
            var currentEdge = EdgeTmp[i];
            if(visited[index] == currentEdge.from 
              && visited[index+1] == currentEdge.to 
              && visited[index+2] == EdgeTmp[index+1].to 
              && findNodeByName(visited[index+1]).evidence == true)
            {
              return "Independent";
            }
            else if(visited[index+1] == currentEdge.to 
              && visited[index+2] == EdgeTmp[index+1].from 
              && visited[index+3] == EdgeTmp[index+1].to 
              && findNodeByName(visited[index+2]).evidence == true){
              return "Independent";
            }
            else{
              index = index + 2;
            }
          }
          return "Dependent";
        }

      }
      function highlightPath(str){
        edgeAC = new Edge("AC", "A", "C", false, false);  
        edgeCF = new Edge("CF", "C", "F", false, false);
        edgeBF = new Edge("BF", "B", "F", false, false);
        edgeCG = new Edge("CG", "C", "G", false, false);
        edgeAD = new Edge("AD", "A", "D", false, false);
        edgeDG = new Edge("DG", "D" ,"G", false, false);
        edgeDH = new Edge("DH", "D", "H", false, false);
        edgeEH = new Edge("EH", "E", "H", false, false);
        EdgeList = [edgeAC, edgeCF, edgeBF, edgeCG, edgeAD, edgeDG, edgeDH,edgeEH];
        //This part is for highlighting the edges
        for(var j = 0; j < str.length; j++){
          for(var i = 0; i < EdgeList.length; i++){
            if(j+1 < str.length && EdgeList[i].name.indexOf(str.charAt(j)) != -1 && EdgeList[i].name.indexOf(str.charAt(j+1)) != -1){
              var tmpEdge = EdgeList[i];
              EdgeList[i] = new Edge(tmpEdge.name, tmpEdge.from, tmpEdge.to, true, false);
            }
          }
        }
      }

    </script>
    <div class="span12">
       <p class="text-info">black is for normal, red is for evidence, blue for X set, and green for Y set</p>
    </div>
    <div class="span6">
      <table class="table table-bordered table-condensed table-striped table-hover">
        <tr>
          <th>Node</th>
          <th>X</th>
          <th>Y</th>
          <th>E</th>
          <th>Clear</th>
        </tr>
        <tr>
          
          <td>
           <label>A</label>
          </td>
           <td>
            <input id="nodeA_X" type="radio" name="nodeA" value="X">
          </td>
           <td>
            <input id="nodeA_Y" type="radio" name="nodeA" value="Y">
          </td>
           <td>
            <input id="nodeA_E" type="radio" name="nodeA" value="E">
          </td>
           <td>
            <input id="nodeA_C"type="radio" name="nodeA" value="C">
          </td>
        </tr>


        <tr>
          <td><label>B</label></td>
          <td>
            <input id="nodeB_X" type="radio" name="nodeB" value="B">
          </td>
           <td>
            <input id="nodeB_Y" type="radio" name="nodeB" value="B">
          </td>
           <td>
            <input id="nodeB_E" type="radio" name="nodeB" value="B">
          </td>
           <td>
            <input id="nodeB_C" type="radio" name="nodeB" value="B">
          </td>
        </tr>
        <tr>
          <td><label>C</label></td>
          <td>
            <input id="nodeC_X" type="radio" name="nodeC" value="C">
          </td>
           <td>
            <input id="nodeC_Y" type="radio" name="nodeC" value="C">
          </td>
           <td>
            <input id="nodeC_E" type="radio" name="nodeC" value="C">
          </td>
           <td>
            <input id="nodeC_C" type="radio" name="nodeC" value="C">
          </td>
        </tr>

        <tr>
          
          <td>
           <label>D</label>
          </td>
           <td>
            <input id="nodeD_X" type="radio" name="nodeD" value="X">
          </td>
           <td>
            <input id="nodeD_Y" type="radio" name="nodeD" value="Y">
          </td>
           <td>
            <input id="nodeD_E" type="radio" name="nodeD" value="E">
          </td>
           <td>
            <input id="nodeD_C"type="radio" name="nodeD" value="C">
          </td>
        </tr>

        <tr>
          
          <td>
           <label>E</label>
          </td>
           <td>
            <input id="nodeE_X" type="radio" name="nodeE" value="X">
          </td>
           <td>
            <input id="nodeE_Y" type="radio" name="nodeE" value="Y">
          </td>
           <td>
            <input id="nodeE_E" type="radio" name="nodeE" value="E">
          </td>
           <td>
            <input id="nodeE_C" type="radio" name="nodeE" value="C">
          </td>
        </tr>

        <tr>
          
          <td>
           <label>F</label>
          </td>
           <td>
            <input id="nodeF_X" type="radio" name="nodeF" value="X">
          </td>
           <td>
            <input id="nodeF_Y" type="radio" name="nodeF" value="Y">
          </td>
           <td>
            <input id="nodeF_E" type="radio" name="nodeF" value="E">
          </td>
           <td>
            <input id="nodeF_C" type="radio" name="nodeF" value="C">
          </td>
        </tr>

        <tr>
          
          <td>
           <label>G</label>
          </td>
           <td>
            <input id="nodeG_X" type="radio" name="nodeG" value="X">
          </td>
           <td>
            <input id="nodeG_Y" type="radio" name="nodeG" value="Y">
          </td>
           <td>
            <input id="nodeG_E" type="radio" name="nodeG" value="E">
          </td>
           <td>
            <input id="nodeG_C" type="radio" name="nodeG" value="C">
          </td>
        </tr>

        <tr>
          
          <td>
           <label>H</label>
          </td>
           <td>
            <input id="nodeH_X" type="radio" name="nodeH" value="X">
          </td>
           <td>
            <input id="nodeH_Y" type="radio" name="nodeH" value="Y">
          </td>
           <td>
            <input id="nodeH_E" type="radio" name="nodeH" value="E">
          </td>
           <td>
            <input id="nodeH_C" type="radio" name="nodeH" value="C">
          </td>
        </tr>

        </table>
      </div>
      <div class="span4">
        <p id="result"></p>
      </div>
    <div class="row-fluid">
      <div class="span12">
        <div class="span1"></div>
        <div class="span1">
          <button class="btn btn-primary" type="button" onclick="init();">Start</button>
        </div>
        <div class="span1">
          <button class="btn btn-success" type="button" onclick="update();">Refresh</button>
        </div>
        <div class="span2">
          <button class="btn btn-info" type="button" name="submit" onClick="allPath();">Submit</button>
        </div>
        <div class="span2">
          <button class="btn btn-info" type="button" name="submit" onClick="D_Separation();">Test</button>
        </div>
      </div>
    </div>

  </body>
</html>
