<html>
  <head>
    <title></title>
    <style>
      td{
        text-align: center;
      }
    </style>

    <link href="css/bootstrap.css" rel="stylesheet" media="screen">
  </head>
  <body>
    <!-- A navbar -->
    <div class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="#">CSE 150 D-Separation Graph</a>
        <ul class="nav">
          <li class="active"><a href="#"><i class="icon-home"></i> Home</a></li>
          <li><a href="#"><i class="icon-book"></i> Course Home Page</a></li>
          <li><a href="#"><i class="icon-search"></i> Useful Links</a></li>
        </ul>
      </div>
    </div>


    <canvas id="viewport" width="1000" height="400"></canvas>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
    <script src="js/bootstrap.js"></script>
    
    <script src="lib/arbor.js"></script>
    <script src="_/graphics.js"></script>
   <!-- <script src="main.js"></script>--> 
    <script>

      //Declare all the variables
      var nodeA;
      var nodeB;
      var nodeC;
      var nodeD;
      var nodeE;
      var nodeF;
      var nodeG;
      var nodeH;
      var NodeList = [];
      var ExampleNodeList = [];
      var EdgeList = [];
      var ExampleEdgeList = [];
      var edgeAC; 
      var edgeCF; 
      var edgeBF; 
      var edgeCG; 
      var edgeAD; 
      var edgeDG; 
      var edgeDH;
      var edgeEH;


      /**
       * Class: Node
       **/
      function Node(name, x, y, mass, evidence, target, targetY){
        this.name = name;
        this.x = x;
        this.y = y;
        this.mass = mass;
        //Red for evidence set
        this.evidence = evidence;
        //Blue for x set
        this.target = target;
        //Green for y set
        this.targetY = targetY;
      }
      /**
       * Class: Edge
       **/
       function Edge(name, from, to, highlighted, rule){
        this.name = name;
        this.from = from;
        this.to = to;
        this.rule = rule;
        this.highlighted = highlighted;
       }

    (function($){

      var Renderer = function(canvas){
      var canvas = $(canvas).get(0)
      var ctx = canvas.getContext("2d");
      var gfx = arbor.Graphics(canvas)
      var particleSystem

      var that = {
      init:function(system){
        //
        // the particle system will call the init function once, right before the
        // first frame is to be drawn. it's a good place to set up the canvas and
        // to pass the canvas size to the particle system
        //
        // save a reference to the particle system for use in the .redraw() loop
        particleSystem = system

        // inform the system of the screen dimensions so it can map coords for us.
        // if the canvas is ever resized, screenSize should be called again with
        // the new dimensions
        particleSystem.screenSize(canvas.width, canvas.height) 
        particleSystem.screenPadding(100) // leave an extra 80px of whitespace per side
        
        // set up some event handlers to allow for node-dragging
        that.initMouseHandling()
      },
      
      redraw:function(){
        // 
        // redraw will be called repeatedly during the run whenever the node positions
        // change. the new positions for the nodes can be accessed by looking at the
        // .p attribute of a given node. however the p.x & p.y values are in the coordinates
        // of the particle system rather than the screen. you can either map them to
        // the screen yourself, or use the convenience iterators .eachNode (and .eachEdge)
        // which allow you to step through the actual node objects but also pass an
        // x,y point in the screen's coordinate system
        // 
        for (var i = 0; i < NodeList.length; i++){
          //alert("e");
          var tmp = NodeList[i];
          particleSystem.addNode(tmp.name, {name: tmp.name, x: tmp.x, y: tmp.y, mass: 2, evidence: tmp.evidence, target: tmp.target, targetY: tmp.targetY});
        }
        for(var i = 0; i < ExampleNodeList.length; i++){
          var tmp = ExampleNodeList[i];
          particleSystem.addNode(tmp.name, {name: tmp.name, x: tmp.x, y: tmp.y, mass: 2, evidence: tmp.evidence, target: tmp.target, targetY: tmp.targetY});
        }
        for (var i = 0; i < EdgeList.length; i++){
          var tmp = EdgeList[i];
          var from = particleSystem.getNode(tmp.from);
          var to = particleSystem.getNode(tmp.to);
          particleSystem.addEdge(from, to, {weight: 2, name: tmp.name, highlighted: tmp.highlighted, rule: tmp.rule});
        }
        for(var i = 0; i < ExampleEdgeList.length; i++){
          var tmp = ExampleEdgeList[i];
          var from = particleSystem.getNode(tmp.from);
          var to = particleSystem.getNode(tmp.to);
          particleSystem.addEdge(from, to, {weight: 2, name: tmp.name, highlighted: tmp.highlighted, rule: tmp.rule});
        }
    
        ctx.fillStyle = "white"
        ctx.fillRect(0,0, canvas.width, canvas.height)
        
        var nodeBoxes = {}
        particleSystem.eachNode(function(node, pt){
          // node: {mass:#, p:{x,y}, name:"", data:{}}
          // pt:   {x:#, y:#}  node position in screen coords

          // draw a rectangle centered at pt
          var w = 10
          if(node.data.evidence)
            ctx.fillStyle = "red"
          else if(node.data.target)
            ctx.fillStyle = "blue"
          else if(node.data.targetY)
            ctx.fillStyle = "green"
          else
            ctx.fillStyle = "black"
          //ctx.fillStyle = (node.data.evidence) ? "red" : "black"
          //ctx.fillRect(pt.x-w/2, pt.y-w/2, w,w)
          ctx.beginPath()
          ctx.arc(node.p.x, node.p.y, 10, 0, 2*Math.PI);
          ctx.fillText(node.data.name, node.p.x+10, node.p.y-3);
          ctx.fill();
          nodeBoxes[node.name] = [node.p.x, node.p.y, 22, 15]
        })   

        particleSystem.eachEdge(function(edge, pt1, pt2){
          // edge: {source:Node, target:Node, length:#, data:{}}
          // pt1:  {x:#, y:#}  source position in screen coords
          // pt2:  {x:#, y:#}  target position in screen coords

          // draw a line from pt1 to pt2
          var weight = edge.data.weight
          var start = nodeBoxes[edge.data.name.charAt(0)]
          var end = nodeBoxes[edge.data.name.charAt(1)]
          ctx.save() 
          ctx.beginPath()
          ctx.lineWidth = (!isNaN(weight)) ? parseFloat(weight) : 1

          if(edge.data.highlighted)
            ctx.strokeStyle = "#99FFFF"
          else
            ctx.strokeStyle = "#cccccc"
          ctx.fillStyle = null

          ctx.moveTo(start[0], start[1])//Tail
          var endx = end[0]
          var endy = end[1]
          if(start[0] > end[0] && start[1] == end[1]){
            endx = end[0] + 12;
          }
          else if(start[0] > end[0]){//The node is on the left side
            endx = end[0] + 10;
            endy = end[1] - 10;
          }
          else if(start[1] == end[1] && start[0] < end[0]){
            endx = end[0] - 12;
          }                  
          else{
            endx = end[0] - 10;
            endy = end[1] - 10;
          }

          //ctx.lineTo(end[0]-5, end[1]-5)//Head
          ctx.lineTo(endx, endy)

          ctx.stroke()
          ctx.restore()

          // draw an arrowhead if this is a -> style edge
          
          ctx.save()
          // move to the head position of the edge we just drew
          var wt = !isNaN(weight) ? parseFloat(weight) : 1
          var arrowLength = 12 + wt
          var arrowWidth = 4 + wt
          ctx.fillStyle = "#cccccc"
          ctx.translate(endx, endy);
          ctx.rotate(Math.atan2(endy - start[1], endx - start[0]));

          // delete some of the edge that's already there (so the point isn't hidden)
          ctx.clearRect(-arrowLength/2,-wt/2, arrowLength/2,wt)

          // draw the chevron
          ctx.beginPath();
          ctx.moveTo(-arrowLength, arrowWidth);
          ctx.lineTo(0, 0);
          ctx.lineTo(-arrowLength, -arrowWidth);
          ctx.lineTo(-arrowLength * 0.8, -0);
          ctx.closePath();
          ctx.fill();
          ctx.restore()

        })

      },
      
      initMouseHandling:function(){
        // no-nonsense drag and drop (thanks springy.js)
        var dragged = null;

        // set up a handler object that will initially listen for mousedowns then
        // for moves and mouseups while dragging
        var handler = {
          clicked:function(e){
            var pos = $(canvas).offset();
            _mouseP = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)
            dragged = particleSystem.nearest(_mouseP);

            if (dragged && dragged.node !== null){
              // while we're dragging, don't let physics move the node
              dragged.node.fixed = true
            }

            $(canvas).bind('mousemove', handler.dragged)
            $(window).bind('mouseup', handler.dropped)

            return false
          },
          dragged:function(e){
            var pos = $(canvas).offset();
            var s = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)

            if (dragged && dragged.node !== null){
              var p = particleSystem.fromScreen(s)
              dragged.node.p = p
            }

            return false
          },

          dropped:function(e){
            if (dragged===null || dragged.node===undefined) return
            if (dragged.node !== null) dragged.node.fixed = false
            dragged.node.tempMass = 1000
            dragged = null
            $(canvas).unbind('mousemove', handler.dragged)
            $(window).unbind('mouseup', handler.dropped)
            _mouseP = null
            return false
          }
        }
        
        // start listening
        $(canvas).mousedown(handler.clicked);

      },
      
    }
    return that
  }    

   // helpers for figuring out where to draw arrows (thanks springy.js)
  var intersect_line_line = function(p1, p2, p3, p4)
  {
    var denom = ((p4.y - p3.y)*(p2.x - p1.x) - (p4.x - p3.x)*(p2.y - p1.y));
    if (denom === 0) return false // lines are parallel
    var ua = ((p4.x - p3.x)*(p1.y - p3.y) - (p4.y - p3.y)*(p1.x - p3.x)) / denom;
    var ub = ((p2.x - p1.x)*(p1.y - p3.y) - (p2.y - p1.y)*(p1.x - p3.x)) / denom;

    if (ua < 0 || ua > 1 || ub < 0 || ub > 1)  return false
      return arbor.Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
  }

  var intersect_line_box = function(p1, p2, boxTuple)
  {
    var p3 = {x:boxTuple[0], y:boxTuple[1]},
        w = boxTuple[2],
        h = boxTuple[3]

          var tl = {x: p3.x, y: p3.y};
    var tr = {x: p3.x + w, y: p3.y};
    var bl = {x: p3.x, y: p3.y + h};
    var br = {x: p3.x + w, y: p3.y + h};

    return intersect_line_line(p1, p2, tl, tr) ||
      intersect_line_line(p1, p2, tr, br) ||
      intersect_line_line(p1, p2, br, bl) ||
      intersect_line_line(p1, p2, bl, tl) ||
      false
  }

  $(document).ready(function(){
    var sys = arbor.ParticleSystem(0, 0, 0.5) // create the system with sensible repulsion/stiffness/friction
    sys.parameters({gravity:true}) // use center-gravity to make the graph settle nicely (ymmv)
    sys.renderer = Renderer("#viewport") // our newly created renderer will have its .init() method called shortly by sys...

    


    // add some nodes to the graph and watch it go...
    // or, equivalently:
    //
    // sys.graft({
    //   nodes:{
    //     f:{alone:true, mass:.25}
    //   }, 
    //   edges:{
    //     a:{ b:{},
    //         c:{},
    //         d:{},
    //         e:{}
    //     }
    //   }
    // })
    
  })

})(this.jQuery)

      //Init condition, set up edges and nodes
      function init(){
        //name, x, y, mass, evidence, target, targetY){
        nodeA = new Node("A", 350, 100, 2, false,  false, false);
        nodeB = new Node("B", 50,  200,  2, false, false, false);
        nodeC = new Node("C", 250, 200, 2, false,  false, false);
        nodeD = new Node("D", 450, 200, 2, false, false, false);
        nodeE = new Node("E", 650, 200, 2, false, false, false);
        nodeF = new Node("F", 150, 300, 2, false, false, false);
        nodeG = new Node("G", 350, 300, 2, false,  false, false);
        nodeH = new Node("H", 550, 300, 2, false,  false, false);

        //Here's for the three possible blocking path

        //Rule #1, intervening cause
        node1 = new Node("1", 720, 50, 2, false, false, false);
        node2 = new Node("2", 795, 50, 2, true, false, false);
        node3 = new Node("3", 870, 50, 2, false, false, false);
        edge12 = new Edge("12", "1", "2", false, true);
        edge23 = new Edge("23", "2", "3", false, true);
        //Rule #2, comman cause
        node4 = new Node("4", 720, 150, 2, false, false, false);
        node5 = new Node("5", 795, 150, 2, true, false, false);
        node6 = new Node("6", 870, 150, 2, false, false, false);

        edge54 = new Edge("54", "5", "4", false, true);
        edge56 = new Edge("56", "5", "6", false, true);
        //Rule #3, no observed common effect
        node7 = new Node("7", 720, 250, 2, false, false, false);
        node8 = new Node("8", 795, 250, 2, false, false, false);
        node9 = new Node("9", 870, 250, 2, false, false, false);
        node10 = new Node("W", 760, 300, 2, false, false, false);
        node11 = new Node("K", 835, 300, 2, false, false, false);
        
        edge78 = new Edge("78", "7", "8", false, true);
        edge98 = new Edge("98", "9", "8", false, true);
        edge8W = new Edge("8W", "8", "W", false, true);
        edge8K = new Edge("8K", "8", "K", false, true);

        NodeList = [nodeA, nodeB, nodeC, nodeD, nodeE, nodeF, nodeG, nodeH] 
        ExampleNodeList = [node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11];


        edgeAC = new Edge("AC", "A", "C", true, false);  
        edgeCF = new Edge("CF", "C", "F", false, false);
        edgeBF = new Edge("BF", "B", "F", false, false);
        edgeCG = new Edge("CG", "C", "G", false, false);
        edgeAD = new Edge("AD", "A", "D", false, false);
        edgeDG = new Edge("DG", "D" ,"G", false, false);
        edgeDH = new Edge("DH", "D", "H", false, false);
        edgeEH = new Edge("EH", "E", "H", false, false);
        EdgeList = [edgeAC, edgeCF, edgeBF, edgeCG, edgeAD, edgeDG, edgeDH,edgeEH]
        ExampleEdgeList = [edge12, edge23, edge54, edge56, edge78, edge98, edge8K, edge8W];

        alert("init");
      }
      //Function update listen to the radio button clicked and update
      //the node as required.
      function update(){

        //Case for node A
        var radios = document.getElementById('nodeA_X');

        //Node A update
        if(document.getElementById('nodeA_X').checked){
          nodeA = new Node("A", 350, 100, 2, false,  true, false);
          NodeList[0] = nodeA;
        }
        else if(document.getElementById('nodeA_Y').checked){
          nodeA = new Node("A", 350, 100, 2, false, false,  true);
          NodeList[0] = nodeA;
        }
        else if(document.getElementById('nodeA_E').checked){
          nodeA = new Node("A", 350, 100, 2, true, false,  false);
          NodeList[0] = nodeA;
        }


        //Node B update
        if(document.getElementById('nodeB_X').checked){
          nodeB = new Node("B", 50, 200, 2, false,  true, false);
          NodeList[1] = nodeB;
        }
        else if(document.getElementById('nodeB_Y').checked){
          nodeB = new Node("B", 50, 200, 2, false, false,  true);
          NodeList[1] = nodeB;
        }
        else if(document.getElementById('nodeB_E').checked){
          nodeB = new Node("B", 50, 200, 2, true, false,  false);
          NodeList[1] = nodeB;
        }


        //Node C update
        if(document.getElementById('nodeC_X').checked){
          nodeC = new Node("C", 250, 200, 2, false,  true, false);
          NodeList[2] = nodeC;
        }
        else if(document.getElementById('nodeC_Y').checked){
          nodeC = new Node("C", 250, 200, 2, false, false,  true);
          NodeList[2] = nodeC;
        }
        else if(document.getElementById('nodeC_E').checked){
          nodeC = new Node("C", 250, 200, 2, true, false,  false);
          NodeList[2] = nodeC;
        }


        //Node D update
        if(document.getElementById('nodeD_X').checked){
          nodeD = new Node("D", 450, 200, 2, false,  true, false);
          NodeList[3] = nodeD;
        }
        else if(document.getElementById('nodeD_Y').checked){
          nodeD = new Node("D", 450, 200, 2, false, false,  true);
          NodeList[3] = nodeD;
        }
        else if(document.getElementById('nodeD_E').checked){
          nodeD = new Node("D", 450, 200, 2, true, false,  false);
          NodeList[3] = nodeD;
        }

        //Node E update
        if(document.getElementById('nodeE_X').checked){
          nodeE = new Node("E", 650, 200, 2, false,  true, false);
          NodeList[4] = nodeE;
        }
        else if(document.getElementById('nodeE_Y').checked){
          nodeE = new Node("E", 650, 200, 2, false, false,  true);
          NodeList[4] = nodeE;
        }
        else if(document.getElementById('nodeE_E').checked){
          nodeE = new Node("E", 650, 200, 2, true, false,  false);
          NodeList[4] = nodeE;
        }


        //Node F update
        if(document.getElementById('nodeF_X').checked){
          nodeF = new Node("F", 150, 300, 2, false,  true, false);
          NodeList[5] = nodeF;
        }
        else if(document.getElementById('nodeF_Y').checked){
          nodeF = new Node("F", 150, 300, 2, false, false,  true);
          NodeList[5] = nodeF;
        }
        else if(document.getElementById('nodeF_E').checked){
          nodeF = new Node("F", 150, 300, 2, true, false,  false);
          NodeList[5] = nodeF;
        }

        //Node G update
        if(document.getElementById('nodeG_X').checked){
          nodeG = new Node("G", 350, 300, 2, false,  true, false);
          NodeList[6] = nodeG;
        }
        else if(document.getElementById('nodeG_Y').checked){
          nodeG = new Node("G", 350, 300, 2, false, false,  true);
          NodeList[6] = nodeG;
        }
        else if(document.getElementById('nodeG_E').checked){
          nodeG = new Node("G", 350, 300, 2, true, false,  false);
          NodeList[6] = nodeG;
        }

        //Node H update
        if(document.getElementById('nodeH_X').checked){
          nodeH = new Node("H", 550, 300, 2, false,  true, false);
          NodeList[7] = nodeH;
        }
        else if(document.getElementById('nodeH_Y').checked){
          nodeH = new Node("H", 550, 300, 2, false, false,  true);
          NodeList[7] = nodeH;
        }
        else if(document.getElementById('nodeH_E').checked){
          nodeH = new Node("H", 550, 300, 2, true, false,  false);
          NodeList[7] = nodeH;
        }
        
      }

    </script>
    <div class="span12">
       <p class="text-info">black is for normal, red is for evidence, blue for X set, and green for Y set</p>
    </div>
    <div class="span8">
    <table class="table table-bordered table-condensed table-striped table-hover">
      <tr>
        <th>Node</th>
        <th>X</th>
        <th>Y</th>
        <th>E</th>
        <th>Clear</th>
      </tr>
      <tr>
        
        <td>
         <label>A</label>
        </td>
         <td>
          <input id="nodeA_X" type="radio" name="nodeA" value="X">
        </td>
         <td>
          <input id="nodeA_Y" type="radio" name="nodeA" value="Y">
        </td>
         <td>
          <input id="nodeA_E" type="radio" name="nodeA" value="E">
        </td>
         <td>
          <input id="nodeA_C"type="radio" name="nodeA" value="C">
        </td>
      </tr>


      <tr>
        <td><label>B</label></td>
        <td>
          <input id="nodeB_X" type="radio" name="nodeB" value="B">
        </td>
         <td>
          <input id="nodeB_Y" type="radio" name="nodeB" value="B">
        </td>
         <td>
          <input id="nodeB_E" type="radio" name="nodeB" value="B">
        </td>
         <td>
          <input id="nodeB_C" type="radio" name="nodeB" value="B">
        </td>
      </tr>
      <tr>
        <td><label>C</label></td>
        <td>
          <input id="nodeC_X" type="radio" name="nodeC" value="C">
        </td>
         <td>
          <input id="nodeC_Y" type="radio" name="nodeC" value="C">
        </td>
         <td>
          <input id="nodeC_E" type="radio" name="nodeC" value="C">
        </td>
         <td>
          <input id="nodeC_C" type="radio" name="nodeC" value="C">
        </td>
      </tr>

      <tr>
        
        <td>
         <label>D</label>
        </td>
         <td>
          <input id="nodeD_X" type="radio" name="nodeD" value="X">
        </td>
         <td>
          <input id="nodeD_Y" type="radio" name="nodeD" value="Y">
        </td>
         <td>
          <input id="nodeD_E" type="radio" name="nodeD" value="E">
        </td>
         <td>
          <input id="nodeD_C"type="radio" name="nodeD" value="C">
        </td>
      </tr>

      <tr>
        
        <td>
         <label>E</label>
        </td>
         <td>
          <input id="nodeE_X" type="radio" name="nodeE" value="X">
        </td>
         <td>
          <input id="nodeE_Y" type="radio" name="nodeE" value="Y">
        </td>
         <td>
          <input id="nodeE_E" type="radio" name="nodeE" value="E">
        </td>
         <td>
          <input id="nodeE_C" type="radio" name="nodeE" value="C">
        </td>
      </tr>

      <tr>
        
        <td>
         <label>F</label>
        </td>
         <td>
          <input id="nodeF_X" type="radio" name="nodeF" value="X">
        </td>
         <td>
          <input id="nodeF_Y" type="radio" name="nodeF" value="Y">
        </td>
         <td>
          <input id="nodeF_E" type="radio" name="nodeF" value="E">
        </td>
         <td>
          <input id="nodeF_C" type="radio" name="nodeF" value="C">
        </td>
      </tr>

      <tr>
        
        <td>
         <label>G</label>
        </td>
         <td>
          <input id="nodeG_X" type="radio" name="nodeG" value="X">
        </td>
         <td>
          <input id="nodeG_Y" type="radio" name="nodeG" value="Y">
        </td>
         <td>
          <input id="nodeG_E" type="radio" name="nodeG" value="E">
        </td>
         <td>
          <input id="nodeG_C" type="radio" name="nodeG" value="C">
        </td>
      </tr>

      <tr>
        
        <td>
         <label>H</label>
        </td>
         <td>
          <input id="nodeH_X" type="radio" name="nodeH" value="X">
        </td>
         <td>
          <input id="nodeH_Y" type="radio" name="nodeH" value="Y">
        </td>
         <td>
          <input id="nodeH_E" type="radio" name="nodeH" value="E">
        </td>
         <td>
          <input id="nodeH_C" type="radio" name="nodeH" value="C">
        </td>
      </tr>

      </table>
    </div>
    <div class="row-fluid">
      <div class="span12">
        <div class="span1"></div>
        <div class="span1">
          <button class="btn btn-primary" type="button" onclick="init();">Start</button>
        </div>
        <div class="span1">
          <button class="btn btn-success" type="button" onclick="update();">Refresh</button>
        </div>
        <div class="span2">
          <button class="btn btn-info" type="button" name="submit" >Submit</button>
        </div>
      </div>
    </div>

  </body>
</html>
